import {
  require_string_trim,
  require_whitespaces
} from "./chunk-ZUNZSUNP.js";
import {
  require_is_regexp
} from "./chunk-JNJVKBIS.js";
import {
  require_species_constructor
} from "./chunk-ZSCJDNBJ.js";
import {
  require_array_method_is_strict,
  require_regexp_get_flags
} from "./chunk-3JN5YVZI.js";
import {
  require_advance_string_index,
  require_array_slice_simple,
  require_fix_regexp_well_known_symbol_logic,
  require_inherit_if_required,
  require_regexp_exec,
  require_regexp_exec_abstract,
  require_regexp_sticky_helpers,
  require_regexp_unsupported_dot_all,
  require_regexp_unsupported_ncg,
  require_to_string
} from "./chunk-MYJXNO5K.js";
import {
  require_an_object,
  require_create_non_enumerable_property,
  require_define_built_in,
  require_descriptors,
  require_export,
  require_fails,
  require_function_apply,
  require_function_call,
  require_function_name,
  require_function_uncurry_this,
  require_get_method,
  require_global,
  require_has_own_property,
  require_indexed_object,
  require_internal_state,
  require_is_forced,
  require_is_null_or_undefined,
  require_object_define_property,
  require_object_get_own_property_names,
  require_object_is_prototype_of,
  require_require_object_coercible,
  require_set_species,
  require_to_indexed_object,
  require_to_length,
  require_try_to_string,
  require_well_known_symbol
} from "./chunk-L4GB7WNN.js";
import {
  __commonJS,
  __esm,
  init_define_import_meta_env
} from "./chunk-63WBANMH.js";

// node_modules/core-js/modules/es.array.join.js
var $, uncurryThis, IndexedObject, toIndexedObject, arrayMethodIsStrict, nativeJoin, ES3_STRINGS, STRICT_METHOD;
var init_es_array_join = __esm({
  "node_modules/core-js/modules/es.array.join.js"() {
    "use strict";
    init_define_import_meta_env();
    $ = require_export();
    uncurryThis = require_function_uncurry_this();
    IndexedObject = require_indexed_object();
    toIndexedObject = require_to_indexed_object();
    arrayMethodIsStrict = require_array_method_is_strict();
    nativeJoin = uncurryThis([].join);
    ES3_STRINGS = IndexedObject != Object;
    STRICT_METHOD = arrayMethodIsStrict("join", ",");
    $({ target: "Array", proto: true, forced: ES3_STRINGS || !STRICT_METHOD }, {
      join: function join(separator) {
        return nativeJoin(toIndexedObject(this), separator === void 0 ? "," : separator);
      }
    });
  }
});

// node_modules/core-js/modules/es.string.match.js
var call, fixRegExpWellKnownSymbolLogic, anObject, isNullOrUndefined, toLength, toString, requireObjectCoercible, getMethod, advanceStringIndex, regExpExec;
var init_es_string_match = __esm({
  "node_modules/core-js/modules/es.string.match.js"() {
    "use strict";
    init_define_import_meta_env();
    call = require_function_call();
    fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    anObject = require_an_object();
    isNullOrUndefined = require_is_null_or_undefined();
    toLength = require_to_length();
    toString = require_to_string();
    requireObjectCoercible = require_require_object_coercible();
    getMethod = require_get_method();
    advanceStringIndex = require_advance_string_index();
    regExpExec = require_regexp_exec_abstract();
    fixRegExpWellKnownSymbolLogic("match", function(MATCH2, nativeMatch, maybeCallNative) {
      return [
        function match(regexp) {
          var O = requireObjectCoercible(this);
          var matcher = isNullOrUndefined(regexp) ? void 0 : getMethod(regexp, MATCH2);
          return matcher ? call(matcher, regexp, O) : new RegExp(regexp)[MATCH2](toString(O));
        },
        function(string) {
          var rx = anObject(this);
          var S = toString(string);
          var res = maybeCallNative(nativeMatch, rx, S);
          if (res.done)
            return res.value;
          if (!rx.global)
            return regExpExec(rx, S);
          var fullUnicode = rx.unicode;
          rx.lastIndex = 0;
          var A = [];
          var n = 0;
          var result;
          while ((result = regExpExec(rx, S)) !== null) {
            var matchStr = toString(result[0]);
            A[n] = matchStr;
            if (matchStr === "")
              rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
            n++;
          }
          return n === 0 ? null : A;
        }
      ];
    });
  }
});

// node_modules/core-js/internals/proxy-accessor.js
var require_proxy_accessor = __commonJS({
  "node_modules/core-js/internals/proxy-accessor.js"(exports, module) {
    init_define_import_meta_env();
    var defineProperty = require_object_define_property().f;
    module.exports = function(Target, Source, key) {
      key in Target || defineProperty(Target, key, {
        configurable: true,
        get: function() {
          return Source[key];
        },
        set: function(it) {
          Source[key] = it;
        }
      });
    };
  }
});

// node_modules/core-js/modules/es.regexp.constructor.js
var DESCRIPTORS, global, uncurryThis2, isForced, inheritIfRequired, createNonEnumerableProperty, getOwnPropertyNames, isPrototypeOf, isRegExp, toString2, getRegExpFlags, stickyHelpers, proxyAccessor, defineBuiltIn, fails, hasOwn, enforceInternalState, setSpecies, wellKnownSymbol, UNSUPPORTED_DOT_ALL, UNSUPPORTED_NCG, MATCH, NativeRegExp, RegExpPrototype, SyntaxError, exec, charAt, replace, stringIndexOf, stringSlice, IS_NCG, re1, re2, CORRECT_NEW, MISSED_STICKY, UNSUPPORTED_Y, BASE_FORCED, handleDotAll, handleNCG, RegExpWrapper, keys, index;
var init_es_regexp_constructor = __esm({
  "node_modules/core-js/modules/es.regexp.constructor.js"() {
    init_define_import_meta_env();
    DESCRIPTORS = require_descriptors();
    global = require_global();
    uncurryThis2 = require_function_uncurry_this();
    isForced = require_is_forced();
    inheritIfRequired = require_inherit_if_required();
    createNonEnumerableProperty = require_create_non_enumerable_property();
    getOwnPropertyNames = require_object_get_own_property_names().f;
    isPrototypeOf = require_object_is_prototype_of();
    isRegExp = require_is_regexp();
    toString2 = require_to_string();
    getRegExpFlags = require_regexp_get_flags();
    stickyHelpers = require_regexp_sticky_helpers();
    proxyAccessor = require_proxy_accessor();
    defineBuiltIn = require_define_built_in();
    fails = require_fails();
    hasOwn = require_has_own_property();
    enforceInternalState = require_internal_state().enforce;
    setSpecies = require_set_species();
    wellKnownSymbol = require_well_known_symbol();
    UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
    UNSUPPORTED_NCG = require_regexp_unsupported_ncg();
    MATCH = wellKnownSymbol("match");
    NativeRegExp = global.RegExp;
    RegExpPrototype = NativeRegExp.prototype;
    SyntaxError = global.SyntaxError;
    exec = uncurryThis2(RegExpPrototype.exec);
    charAt = uncurryThis2("".charAt);
    replace = uncurryThis2("".replace);
    stringIndexOf = uncurryThis2("".indexOf);
    stringSlice = uncurryThis2("".slice);
    IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
    re1 = /a/g;
    re2 = /a/g;
    CORRECT_NEW = new NativeRegExp(re1) !== re1;
    MISSED_STICKY = stickyHelpers.MISSED_STICKY;
    UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
    BASE_FORCED = DESCRIPTORS && (!CORRECT_NEW || MISSED_STICKY || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG || fails(function() {
      re2[MATCH] = false;
      return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, "i") != "/a/i";
    }));
    handleDotAll = function(string) {
      var length = string.length;
      var index = 0;
      var result = "";
      var brackets = false;
      var chr;
      for (; index <= length; index++) {
        chr = charAt(string, index);
        if (chr === "\\") {
          result += chr + charAt(string, ++index);
          continue;
        }
        if (!brackets && chr === ".") {
          result += "[\\s\\S]";
        } else {
          if (chr === "[") {
            brackets = true;
          } else if (chr === "]") {
            brackets = false;
          }
          result += chr;
        }
      }
      return result;
    };
    handleNCG = function(string) {
      var length = string.length;
      var index = 0;
      var result = "";
      var named = [];
      var names = {};
      var brackets = false;
      var ncg = false;
      var groupid = 0;
      var groupname = "";
      var chr;
      for (; index <= length; index++) {
        chr = charAt(string, index);
        if (chr === "\\") {
          chr = chr + charAt(string, ++index);
        } else if (chr === "]") {
          brackets = false;
        } else if (!brackets)
          switch (true) {
            case chr === "[":
              brackets = true;
              break;
            case chr === "(":
              if (exec(IS_NCG, stringSlice(string, index + 1))) {
                index += 2;
                ncg = true;
              }
              result += chr;
              groupid++;
              continue;
            case (chr === ">" && ncg):
              if (groupname === "" || hasOwn(names, groupname)) {
                throw new SyntaxError("Invalid capture group name");
              }
              names[groupname] = true;
              named[named.length] = [groupname, groupid];
              ncg = false;
              groupname = "";
              continue;
          }
        if (ncg)
          groupname += chr;
        else
          result += chr;
      }
      return [result, named];
    };
    if (isForced("RegExp", BASE_FORCED)) {
      RegExpWrapper = function RegExp2(pattern, flags) {
        var thisIsRegExp = isPrototypeOf(RegExpPrototype, this);
        var patternIsRegExp = isRegExp(pattern);
        var flagsAreUndefined = flags === void 0;
        var groups = [];
        var rawPattern = pattern;
        var rawFlags, dotAll, sticky, handled, result, state;
        if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
          return pattern;
        }
        if (patternIsRegExp || isPrototypeOf(RegExpPrototype, pattern)) {
          pattern = pattern.source;
          if (flagsAreUndefined)
            flags = getRegExpFlags(rawPattern);
        }
        pattern = pattern === void 0 ? "" : toString2(pattern);
        flags = flags === void 0 ? "" : toString2(flags);
        rawPattern = pattern;
        if (UNSUPPORTED_DOT_ALL && "dotAll" in re1) {
          dotAll = !!flags && stringIndexOf(flags, "s") > -1;
          if (dotAll)
            flags = replace(flags, /s/g, "");
        }
        rawFlags = flags;
        if (MISSED_STICKY && "sticky" in re1) {
          sticky = !!flags && stringIndexOf(flags, "y") > -1;
          if (sticky && UNSUPPORTED_Y)
            flags = replace(flags, /y/g, "");
        }
        if (UNSUPPORTED_NCG) {
          handled = handleNCG(pattern);
          pattern = handled[0];
          groups = handled[1];
        }
        result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
        if (dotAll || sticky || groups.length) {
          state = enforceInternalState(result);
          if (dotAll) {
            state.dotAll = true;
            state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
          }
          if (sticky)
            state.sticky = true;
          if (groups.length)
            state.groups = groups;
        }
        if (pattern !== rawPattern)
          try {
            createNonEnumerableProperty(result, "source", rawPattern === "" ? "(?:)" : rawPattern);
          } catch (error) {
          }
        return result;
      };
      for (keys = getOwnPropertyNames(NativeRegExp), index = 0; keys.length > index; ) {
        proxyAccessor(RegExpWrapper, NativeRegExp, keys[index++]);
      }
      RegExpPrototype.constructor = RegExpWrapper;
      RegExpWrapper.prototype = RegExpPrototype;
      defineBuiltIn(global, "RegExp", RegExpWrapper, { constructor: true });
    }
    setSpecies("RegExp");
  }
});

// node_modules/core-js/internals/string-trim-forced.js
var require_string_trim_forced = __commonJS({
  "node_modules/core-js/internals/string-trim-forced.js"(exports, module) {
    init_define_import_meta_env();
    var PROPER_FUNCTION_NAME = require_function_name().PROPER;
    var fails3 = require_fails();
    var whitespaces = require_whitespaces();
    var non = "\u200B\x85\u180E";
    module.exports = function(METHOD_NAME) {
      return fails3(function() {
        return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
      });
    };
  }
});

// node_modules/core-js/modules/es.string.trim.js
var $2, $trim, forcedStringTrimMethod;
var init_es_string_trim = __esm({
  "node_modules/core-js/modules/es.string.trim.js"() {
    "use strict";
    init_define_import_meta_env();
    $2 = require_export();
    $trim = require_string_trim().trim;
    forcedStringTrimMethod = require_string_trim_forced();
    $2({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
      trim: function trim() {
        return $trim(this);
      }
    });
  }
});

// node_modules/core-js/modules/es.string.split.js
var apply, call2, uncurryThis3, fixRegExpWellKnownSymbolLogic2, anObject2, isNullOrUndefined2, isRegExp2, requireObjectCoercible2, speciesConstructor, advanceStringIndex2, toLength2, toString3, getMethod2, arraySlice, callRegExpExec, regexpExec, stickyHelpers2, fails2, UNSUPPORTED_Y2, MAX_UINT32, min, $push, exec2, push, stringSlice2, SPLIT_WORKS_WITH_OVERWRITTEN_EXEC;
var init_es_string_split = __esm({
  "node_modules/core-js/modules/es.string.split.js"() {
    "use strict";
    init_define_import_meta_env();
    apply = require_function_apply();
    call2 = require_function_call();
    uncurryThis3 = require_function_uncurry_this();
    fixRegExpWellKnownSymbolLogic2 = require_fix_regexp_well_known_symbol_logic();
    anObject2 = require_an_object();
    isNullOrUndefined2 = require_is_null_or_undefined();
    isRegExp2 = require_is_regexp();
    requireObjectCoercible2 = require_require_object_coercible();
    speciesConstructor = require_species_constructor();
    advanceStringIndex2 = require_advance_string_index();
    toLength2 = require_to_length();
    toString3 = require_to_string();
    getMethod2 = require_get_method();
    arraySlice = require_array_slice_simple();
    callRegExpExec = require_regexp_exec_abstract();
    regexpExec = require_regexp_exec();
    stickyHelpers2 = require_regexp_sticky_helpers();
    fails2 = require_fails();
    UNSUPPORTED_Y2 = stickyHelpers2.UNSUPPORTED_Y;
    MAX_UINT32 = 4294967295;
    min = Math.min;
    $push = [].push;
    exec2 = uncurryThis3(/./.exec);
    push = uncurryThis3($push);
    stringSlice2 = uncurryThis3("".slice);
    SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails2(function() {
      var re = /(?:)/;
      var originalExec = re.exec;
      re.exec = function() {
        return originalExec.apply(this, arguments);
      };
      var result = "ab".split(re);
      return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
    });
    fixRegExpWellKnownSymbolLogic2("split", function(SPLIT, nativeSplit, maybeCallNative) {
      var internalSplit;
      if ("abbc".split(/(b)*/)[1] == "c" || "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || ".".split(/()()/).length > 1 || "".split(/.?/).length) {
        internalSplit = function(separator, limit) {
          var string = toString3(requireObjectCoercible2(this));
          var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
          if (lim === 0)
            return [];
          if (separator === void 0)
            return [string];
          if (!isRegExp2(separator)) {
            return call2(nativeSplit, string, separator, lim);
          }
          var output = [];
          var flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.unicode ? "u" : "") + (separator.sticky ? "y" : "");
          var lastLastIndex = 0;
          var separatorCopy = new RegExp(separator.source, flags + "g");
          var match, lastIndex, lastLength;
          while (match = call2(regexpExec, separatorCopy, string)) {
            lastIndex = separatorCopy.lastIndex;
            if (lastIndex > lastLastIndex) {
              push(output, stringSlice2(string, lastLastIndex, match.index));
              if (match.length > 1 && match.index < string.length)
                apply($push, output, arraySlice(match, 1));
              lastLength = match[0].length;
              lastLastIndex = lastIndex;
              if (output.length >= lim)
                break;
            }
            if (separatorCopy.lastIndex === match.index)
              separatorCopy.lastIndex++;
          }
          if (lastLastIndex === string.length) {
            if (lastLength || !exec2(separatorCopy, ""))
              push(output, "");
          } else
            push(output, stringSlice2(string, lastLastIndex));
          return output.length > lim ? arraySlice(output, 0, lim) : output;
        };
      } else if ("0".split(void 0, 0).length) {
        internalSplit = function(separator, limit) {
          return separator === void 0 && limit === 0 ? [] : call2(nativeSplit, this, separator, limit);
        };
      } else
        internalSplit = nativeSplit;
      return [
        function split(separator, limit) {
          var O = requireObjectCoercible2(this);
          var splitter = isNullOrUndefined2(separator) ? void 0 : getMethod2(separator, SPLIT);
          return splitter ? call2(splitter, separator, O, limit) : call2(internalSplit, toString3(O), separator, limit);
        },
        function(string, limit) {
          var rx = anObject2(this);
          var S = toString3(string);
          var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);
          if (res.done)
            return res.value;
          var C = speciesConstructor(rx, RegExp);
          var unicodeMatching = rx.unicode;
          var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y2 ? "g" : "y");
          var splitter = new C(UNSUPPORTED_Y2 ? "^(?:" + rx.source + ")" : rx, flags);
          var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
          if (lim === 0)
            return [];
          if (S.length === 0)
            return callRegExpExec(splitter, S) === null ? [S] : [];
          var p = 0;
          var q = 0;
          var A = [];
          while (q < S.length) {
            splitter.lastIndex = UNSUPPORTED_Y2 ? 0 : q;
            var z = callRegExpExec(splitter, UNSUPPORTED_Y2 ? stringSlice2(S, q) : S);
            var e;
            if (z === null || (e = min(toLength2(splitter.lastIndex + (UNSUPPORTED_Y2 ? q : 0)), S.length)) === p) {
              q = advanceStringIndex2(S, q, unicodeMatching);
            } else {
              push(A, stringSlice2(S, p, q));
              if (A.length === lim)
                return A;
              for (var i = 1; i <= z.length - 1; i++) {
                push(A, z[i]);
                if (A.length === lim)
                  return A;
              }
              q = p = e;
            }
          }
          push(A, stringSlice2(S, p));
          return A;
        }
      ];
    }, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y2);
  }
});

// node_modules/core-js/internals/delete-property-or-throw.js
var require_delete_property_or_throw = __commonJS({
  "node_modules/core-js/internals/delete-property-or-throw.js"(exports, module) {
    "use strict";
    init_define_import_meta_env();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module.exports = function(O, P) {
      if (!delete O[P])
        throw $TypeError("Cannot delete property " + tryToString(P) + " of " + tryToString(O));
    };
  }
});

export {
  init_es_array_join,
  init_es_string_match,
  require_delete_property_or_throw,
  init_es_regexp_constructor,
  require_string_trim_forced,
  init_es_string_trim,
  init_es_string_split
};
//# sourceMappingURL=chunk-7OGGZRZ2.js.map

import {
  require_is_regex,
  require_is_symbol
} from "./chunk-BPBYQXFL.js";
import {
  require_memoizerific
} from "./chunk-KVRPG7SF.js";
import {
  require_get
} from "./chunk-JCW4ILU7.js";
import {
  __commonJS,
  __esm,
  __toESM,
  init_define_import_meta_env
} from "./chunk-63WBANMH.js";

// node_modules/is-function/index.js
var require_is_function = __commonJS({
  "node_modules/is-function/index.js"(exports, module) {
    init_define_import_meta_env();
    module.exports = isFunction2;
    var toString = Object.prototype.toString;
    function isFunction2(fn) {
      if (!fn) {
        return false;
      }
      var string = toString.call(fn);
      return string === "[object Function]" || typeof fn === "function" && string !== "[object RegExp]" || typeof window !== "undefined" && (fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);
    }
  }
});

// node_modules/telejson/node_modules/isobject/index.js
function isObject(val) {
  return val != null && typeof val === "object" && Array.isArray(val) === false;
}
var init_isobject = __esm({
  "node_modules/telejson/node_modules/isobject/index.js"() {
    init_define_import_meta_env();
  }
});

// node_modules/telejson/dist/esm/dom-event.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source2 = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source2), true).forEach(function(key2) {
        _defineProperty(target, key2, source2[key2]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys(Object(source2)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
      });
    }
  }
  return target;
}
function _defineProperty(obj, key2, value2) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value2;
  }
  return obj;
}
function extractEventHiddenProperties(event) {
  var rebuildEvent = eventProperties.filter(function(value2) {
    return event[value2] !== void 0;
  }).reduce(function(acc, value2) {
    return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, value2, event[value2]));
  }, {});
  if (event instanceof CustomEvent) {
    customEventSpecificProperties.filter(function(value2) {
      return event[value2] !== void 0;
    }).forEach(function(value2) {
      rebuildEvent[value2] = event[value2];
    });
  }
  return rebuildEvent;
}
var eventProperties, customEventSpecificProperties;
var init_dom_event = __esm({
  "node_modules/telejson/dist/esm/dom-event.js"() {
    init_define_import_meta_env();
    eventProperties = ["bubbles", "cancelBubble", "cancelable", "composed", "currentTarget", "defaultPrevented", "eventPhase", "isTrusted", "returnValue", "srcElement", "target", "timeStamp", "type"];
    customEventSpecificProperties = ["detail"];
  }
});

// node_modules/telejson/dist/esm/index.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source2 = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys2(Object(source2), true).forEach(function(key2) {
        _defineProperty2(target, key2, source2[key2]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys2(Object(source2)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
      });
    }
  }
  return target;
}
function _defineProperty2(obj, key2, value2) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value2;
  }
  return obj;
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function convertUnconventionalData(data) {
  if (isRunningInBrowser && data instanceof Event) {
    return extractEventHiddenProperties(data);
  }
  return data;
}
var import_is_regex, import_is_function, import_is_symbol, import_get, import_memoizerific, isRunningInBrowser, isObject2, removeCodeComments, cleanCode, convertShorthandMethods, dateFormat, isJSON, replacer, reviver2, defaultOptions, stringify, mutator, parse;
var init_esm = __esm({
  "node_modules/telejson/dist/esm/index.js"() {
    init_define_import_meta_env();
    import_is_regex = __toESM(require_is_regex());
    import_is_function = __toESM(require_is_function());
    import_is_symbol = __toESM(require_is_symbol());
    init_isobject();
    import_get = __toESM(require_get());
    import_memoizerific = __toESM(require_memoizerific());
    init_dom_event();
    isRunningInBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
    isObject2 = isObject;
    removeCodeComments = function removeCodeComments2(code) {
      var inQuoteChar = null;
      var inBlockComment = false;
      var inLineComment = false;
      var inRegexLiteral = false;
      var newCode = "";
      if (code.indexOf("//") >= 0 || code.indexOf("/*") >= 0) {
        for (var i = 0; i < code.length; i += 1) {
          if (!inQuoteChar && !inBlockComment && !inLineComment && !inRegexLiteral) {
            if (code[i] === '"' || code[i] === "'" || code[i] === "`") {
              inQuoteChar = code[i];
            } else if (code[i] === "/" && code[i + 1] === "*") {
              inBlockComment = true;
            } else if (code[i] === "/" && code[i + 1] === "/") {
              inLineComment = true;
            } else if (code[i] === "/" && code[i + 1] !== "/") {
              inRegexLiteral = true;
            }
          } else {
            if (inQuoteChar && (code[i] === inQuoteChar && code[i - 1] !== "\\" || code[i] === "\n" && inQuoteChar !== "`")) {
              inQuoteChar = null;
            }
            if (inRegexLiteral && (code[i] === "/" && code[i - 1] !== "\\" || code[i] === "\n")) {
              inRegexLiteral = false;
            }
            if (inBlockComment && code[i - 1] === "/" && code[i - 2] === "*") {
              inBlockComment = false;
            }
            if (inLineComment && code[i] === "\n") {
              inLineComment = false;
            }
          }
          if (!inBlockComment && !inLineComment) {
            newCode += code[i];
          }
        }
      } else {
        newCode = code;
      }
      return newCode;
    };
    cleanCode = (0, import_memoizerific.default)(1e4)(function(code) {
      return removeCodeComments(code).replace(/\n\s*/g, "").trim();
    });
    convertShorthandMethods = function convertShorthandMethods2(key2, stringified) {
      var fnHead = stringified.slice(0, stringified.indexOf("{"));
      var fnBody = stringified.slice(stringified.indexOf("{"));
      if (fnHead.includes("=>")) {
        return stringified;
      }
      if (fnHead.includes("function")) {
        return stringified;
      }
      var modifiedHead = fnHead;
      modifiedHead = modifiedHead.replace(key2, "function");
      return modifiedHead + fnBody;
    };
    dateFormat = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/;
    isJSON = function isJSON2(input) {
      return input.match(/^[\[\{\"\}].*[\]\}\"]$/);
    };
    replacer = function replacer2(options2) {
      var objects;
      var stack;
      var keys;
      return function replace(key2, value2) {
        try {
          if (key2 === "") {
            keys = [];
            objects = /* @__PURE__ */ new Map([[value2, "[]"]]);
            stack = [];
            return value2;
          }
          while (stack.length && this !== stack[0]) {
            stack.shift();
            keys.pop();
          }
          if (typeof value2 === "boolean") {
            return value2;
          }
          if (value2 === void 0) {
            if (!options2.allowUndefined) {
              return void 0;
            }
            return "_undefined_";
          }
          if (typeof value2 === "number") {
            if (value2 === -Infinity) {
              return "_-Infinity_";
            }
            if (value2 === Infinity) {
              return "_Infinity_";
            }
            if (Number.isNaN(value2)) {
              return "_NaN_";
            }
            return value2;
          }
          if (typeof value2 === "bigint") {
            return "_bigint_".concat(value2.toString());
          }
          if (typeof value2 === "string") {
            if (dateFormat.test(value2)) {
              if (!options2.allowDate) {
                return void 0;
              }
              return "_date_".concat(value2);
            }
            return value2;
          }
          if ((0, import_is_regex.default)(value2)) {
            if (!options2.allowRegExp) {
              return void 0;
            }
            return "_regexp_".concat(value2.flags, "|").concat(value2.source);
          }
          if ((0, import_is_function.default)(value2)) {
            if (!options2.allowFunction) {
              return void 0;
            }
            var name2 = value2.name;
            var stringified = value2.toString();
            if (!stringified.match(/(\[native code\]|WEBPACK_IMPORTED_MODULE|__webpack_exports__|__webpack_require__)/)) {
              return "_function_".concat(name2, "|").concat(cleanCode(convertShorthandMethods(key2, stringified)));
            }
            return "_function_".concat(name2, "|").concat(function() {
            }.toString());
          }
          if ((0, import_is_symbol.default)(value2)) {
            if (!options2.allowSymbol) {
              return void 0;
            }
            var globalRegistryKey = Symbol.keyFor(value2);
            if (globalRegistryKey !== void 0) {
              return "_gsymbol_".concat(globalRegistryKey);
            }
            return "_symbol_".concat(value2.toString().slice(7, -1));
          }
          if (stack.length >= options2.maxDepth) {
            if (Array.isArray(value2)) {
              return "[Array(".concat(value2.length, ")]");
            }
            return "[Object]";
          }
          var found = objects.get(value2);
          if (!found) {
            if (value2 && isObject2(value2) && value2.constructor && value2.constructor.name && value2.constructor.name !== "Object") {
              if (!options2.allowClass) {
                return void 0;
              }
              try {
                Object.assign(value2, {
                  "_constructor-name_": value2.constructor.name
                });
              } catch (e) {
              }
            }
            keys.push(key2);
            stack.unshift(value2);
            objects.set(value2, JSON.stringify(keys));
            return convertUnconventionalData(value2);
          }
          return "_duplicate_".concat(found);
        } catch (e) {
          return void 0;
        }
      };
    };
    reviver2 = function reviver(options) {
      var refs = [];
      var root;
      return function revive(key, value) {
        if (key === "") {
          root = value;
          refs.forEach(function(_ref) {
            var target = _ref.target, container = _ref.container, replacement = _ref.replacement;
            var replacementArr = isJSON(replacement) ? JSON.parse(replacement) : replacement.split(".");
            if (replacementArr.length === 0) {
              container[target] = root;
            } else {
              container[target] = (0, import_get.default)(root, replacementArr);
            }
          });
        }
        if (key === "_constructor-name_") {
          return value;
        }
        if (isObject2(value) && value["_constructor-name_"]) {
          var name = value["_constructor-name_"];
          if (name !== "Object") {
            var Fn = new Function("return function ".concat(name, "(){}"))();
            Object.setPrototypeOf(value, new Fn());
          }
          delete value["_constructor-name_"];
          return value;
        }
        if (typeof value === "string" && value.startsWith("_function_")) {
          var _ref2 = value.match(/_function_([^|]*)\|(.*)/) || [], _ref3 = _slicedToArray(_ref2, 3), _name = _ref3[1], source = _ref3[2];
          var sourceSanitized = source.replace(/[(\(\))|\\| |\]|`]*$/, "");
          if (!options.lazyEval) {
            return eval("(".concat(sourceSanitized, ")"));
          }
          var result = function result() {
            var f = eval("(".concat(sourceSanitized, ")"));
            return f.apply(void 0, arguments);
          };
          Object.defineProperty(result, "toString", {
            value: function value2() {
              return sourceSanitized;
            }
          });
          Object.defineProperty(result, "name", {
            value: _name
          });
          return result;
        }
        if (typeof value === "string" && value.startsWith("_regexp_")) {
          var _ref4 = value.match(/_regexp_([^|]*)\|(.*)/) || [], _ref5 = _slicedToArray(_ref4, 3), flags = _ref5[1], _source = _ref5[2];
          return new RegExp(_source, flags);
        }
        if (typeof value === "string" && value.startsWith("_date_")) {
          return new Date(value.replace("_date_", ""));
        }
        if (typeof value === "string" && value.startsWith("_duplicate_")) {
          refs.push({
            target: key,
            container: this,
            replacement: value.replace(/^_duplicate_/, "")
          });
          return null;
        }
        if (typeof value === "string" && value.startsWith("_symbol_")) {
          return Symbol(value.replace("_symbol_", ""));
        }
        if (typeof value === "string" && value.startsWith("_gsymbol_")) {
          return Symbol["for"](value.replace("_gsymbol_", ""));
        }
        if (typeof value === "string" && value === "_-Infinity_") {
          return -Infinity;
        }
        if (typeof value === "string" && value === "_Infinity_") {
          return Infinity;
        }
        if (typeof value === "string" && value === "_NaN_") {
          return NaN;
        }
        if (typeof value === "string" && value.startsWith("_bigint_") && typeof BigInt === "function") {
          return BigInt(value.replace("_bigint_", ""));
        }
        return value;
      };
    };
    defaultOptions = {
      maxDepth: 10,
      space: void 0,
      allowFunction: true,
      allowRegExp: true,
      allowDate: true,
      allowClass: true,
      allowUndefined: true,
      allowSymbol: true,
      lazyEval: true
    };
    stringify = function stringify2(data) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var mergedOptions = _objectSpread2(_objectSpread2({}, defaultOptions), options2);
      return JSON.stringify(convertUnconventionalData(data), replacer(mergedOptions), options2.space);
    };
    mutator = function mutator2() {
      var mutated = /* @__PURE__ */ new Map();
      return function mutateUndefined(value2) {
        if (isObject2(value2)) {
          Object.entries(value2).forEach(function(_ref6) {
            var _ref7 = _slicedToArray(_ref6, 2), k = _ref7[0], v = _ref7[1];
            if (v === "_undefined_") {
              value2[k] = void 0;
            } else if (!mutated.get(v)) {
              mutated.set(v, true);
              mutateUndefined(v);
            }
          });
        }
        if (Array.isArray(value2)) {
          value2.forEach(function(v, index) {
            mutated.set(v, true);
            mutateUndefined(v);
            if (v === "_undefined_") {
              mutated.set(v, true);
              value2[index] = void 0;
            }
          });
        }
      };
    };
    parse = function parse2(data) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var mergedOptions = _objectSpread2(_objectSpread2({}, defaultOptions), options2);
      var result2 = JSON.parse(data, reviver2(mergedOptions));
      mutator()(result2);
      return result2;
    };
  }
});

export {
  isJSON,
  replacer,
  reviver2 as reviver,
  stringify,
  parse,
  init_esm
};
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
//# sourceMappingURL=chunk-ACFELJHL.js.map

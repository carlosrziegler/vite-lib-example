import {
  logger
} from "./chunk-3FOXOBMZ.js";
import {
  init_es_array_find
} from "./chunk-OXSGFUZ3.js";
import {
  init_es_weak_map
} from "./chunk-OAH7BJYX.js";
import {
  init_es_object_values
} from "./chunk-B3Z7DGEU.js";
import {
  init_es_promise
} from "./chunk-AUU3CWDW.js";
import {
  init_es_array_from,
  init_es_array_includes,
  init_es_array_map,
  init_es_function_name,
  init_es_object_assign,
  init_es_object_entries,
  init_es_string_includes,
  init_es_symbol,
  init_es_symbol_description,
  init_es_symbol_iterator
} from "./chunk-JNJVKBIS.js";
import {
  init_web_immediate
} from "./chunk-47AYDWDR.js";
import {
  esm_default,
  init_esm
} from "./chunk-AGDQOUL7.js";
import {
  require_browser
} from "./chunk-NHJEIV3I.js";
import {
  init_es_array_filter,
  init_es_array_slice,
  init_es_object_freeze,
  init_es_object_keys,
  init_es_regexp_to_string,
  init_web_dom_collections_for_each
} from "./chunk-3JN5YVZI.js";
import {
  init_es_array_concat,
  init_es_set,
  init_web_dom_collections_iterator,
  require_es_array_iterator,
  require_es_regexp_exec,
  require_es_string_iterator
} from "./chunk-MYJXNO5K.js";
import {
  init_es_object_to_string
} from "./chunk-L4GB7WNN.js";
import {
  require_window
} from "./chunk-UY7AYQEB.js";
import {
  __toESM,
  init_define_import_meta_env
} from "./chunk-63WBANMH.js";

// node_modules/@storybook/addons/node_modules/@storybook/channels/dist/esm/index.js
init_define_import_meta_env();
init_es_object_freeze();
init_es_array_slice();
init_es_object_to_string();
init_es_regexp_to_string();
init_web_immediate();
init_es_object_keys();
init_es_array_filter();
init_web_dom_collections_for_each();
var import_util_deprecate = __toESM(require_browser());
init_esm();
var _templateObject;
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var generateRandomId = function generateRandomId2() {
  return Math.random().toString(16).slice(2);
};
var Channel = function() {
  function Channel2() {
    var _this = this;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, transport = _ref.transport, _ref$async = _ref.async, async = _ref$async === void 0 ? false : _ref$async;
    _classCallCheck(this, Channel2);
    this.isAsync = void 0;
    this.sender = generateRandomId();
    this.events = {};
    this.data = {};
    this.transport = void 0;
    this.addPeerListener = (0, import_util_deprecate.default)(function(eventName, listener) {
      _this.addListener(eventName, listener);
    }, esm_default(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n      channel.addPeerListener is deprecated\n    "]))));
    this.isAsync = async;
    if (transport) {
      this.transport = transport;
      this.transport.setHandler(function(event) {
        return _this.handleEvent(event);
      });
    }
  }
  _createClass(Channel2, [{
    key: "hasTransport",
    get: function get() {
      return !!this.transport;
    }
  }, {
    key: "addListener",
    value: function addListener(eventName, listener) {
      this.events[eventName] = this.events[eventName] || [];
      this.events[eventName].push(listener);
    }
  }, {
    key: "emit",
    value: function emit(eventName) {
      var _this2 = this;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var event = {
        type: eventName,
        args,
        from: this.sender
      };
      var options = {};
      if (args.length >= 1 && args[0] && args[0].options) {
        options = args[0].options;
      }
      var handler = function handler2() {
        if (_this2.transport) {
          _this2.transport.send(event, options);
        }
        _this2.handleEvent(event);
      };
      if (this.isAsync) {
        setImmediate(handler);
      } else {
        handler();
      }
    }
  }, {
    key: "last",
    value: function last(eventName) {
      return this.data[eventName];
    }
  }, {
    key: "eventNames",
    value: function eventNames() {
      return Object.keys(this.events);
    }
  }, {
    key: "listenerCount",
    value: function listenerCount(eventName) {
      var listeners = this.listeners(eventName);
      return listeners ? listeners.length : 0;
    }
  }, {
    key: "listeners",
    value: function listeners(eventName) {
      var listeners2 = this.events[eventName];
      return listeners2 || void 0;
    }
  }, {
    key: "once",
    value: function once(eventName, listener) {
      var onceListener = this.onceListener(eventName, listener);
      this.addListener(eventName, onceListener);
    }
  }, {
    key: "removeAllListeners",
    value: function removeAllListeners(eventName) {
      if (!eventName) {
        this.events = {};
      } else if (this.events[eventName]) {
        delete this.events[eventName];
      }
    }
  }, {
    key: "removeListener",
    value: function removeListener(eventName, listener) {
      var listeners = this.listeners(eventName);
      if (listeners) {
        this.events[eventName] = listeners.filter(function(l) {
          return l !== listener;
        });
      }
    }
  }, {
    key: "on",
    value: function on(eventName, listener) {
      this.addListener(eventName, listener);
    }
  }, {
    key: "off",
    value: function off(eventName, listener) {
      this.removeListener(eventName, listener);
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(event) {
      var listeners = this.listeners(event.type);
      if (listeners && listeners.length) {
        listeners.forEach(function(fn) {
          fn.apply(event, event.args);
        });
      }
      this.data[event.type] = event.args;
    }
  }, {
    key: "onceListener",
    value: function onceListener(eventName, listener) {
      var _this3 = this;
      var onceListener2 = function onceListener3() {
        _this3.removeListener(eventName, onceListener3);
        return listener.apply(void 0, arguments);
      };
      return onceListener2;
    }
  }]);
  return Channel2;
}();
var esm_default2 = Channel;

// node_modules/@storybook/addons/dist/esm/storybook-channel-mock.js
init_define_import_meta_env();
function mockChannel() {
  var transport = {
    setHandler: function setHandler() {
    },
    send: function send() {
    }
  };
  return new esm_default2({
    transport
  });
}

// node_modules/@storybook/addons/dist/esm/types.js
init_define_import_meta_env();
init_es_array_find();
init_es_object_to_string();
init_es_object_values();
var types;
(function(types2) {
  types2["TAB"] = "tab";
  types2["PANEL"] = "panel";
  types2["TOOL"] = "tool";
  types2["TOOLEXTRA"] = "toolextra";
  types2["PREVIEW"] = "preview";
  types2["NOTES_ELEMENT"] = "notes-element";
})(types || (types = {}));
function isSupportedType(type) {
  return !!Object.values(types).find(function(typeVal) {
    return typeVal === type;
  });
}

// node_modules/@storybook/addons/dist/esm/index.js
init_define_import_meta_env();
init_es_object_assign();
init_es_object_to_string();
init_web_dom_collections_for_each();
init_es_object_values();
init_es_promise();
var import_global = __toESM(require_window());
function _defineProperties2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var AddonStore = _createClass2(function AddonStore2() {
  var _this = this;
  _classCallCheck2(this, AddonStore2);
  this.loaders = {};
  this.elements = {};
  this.config = {};
  this.channel = void 0;
  this.serverChannel = void 0;
  this.promise = void 0;
  this.resolve = void 0;
  this.getChannel = function() {
    if (!_this.channel) {
      _this.setChannel(mockChannel());
    }
    return _this.channel;
  };
  this.getServerChannel = function() {
    if (!_this.serverChannel) {
      throw new Error("Accessing non-existent serverChannel");
    }
    return _this.serverChannel;
  };
  this.ready = function() {
    return _this.promise;
  };
  this.hasChannel = function() {
    return !!_this.channel;
  };
  this.hasServerChannel = function() {
    return !!_this.serverChannel;
  };
  this.setChannel = function(channel) {
    _this.channel = channel;
    _this.resolve();
  };
  this.setServerChannel = function(channel) {
    _this.serverChannel = channel;
  };
  this.getElements = function(type) {
    if (!_this.elements[type]) {
      _this.elements[type] = {};
    }
    return _this.elements[type];
  };
  this.addPanel = function(name, options) {
    _this.add(name, Object.assign({
      type: types.PANEL
    }, options));
  };
  this.add = function(name, addon) {
    var type = addon.type;
    var collection = _this.getElements(type);
    collection[name] = Object.assign({
      id: name
    }, addon);
  };
  this.setConfig = function(value) {
    Object.assign(_this.config, value);
  };
  this.getConfig = function() {
    return _this.config;
  };
  this.register = function(name, registerCallback) {
    if (_this.loaders[name]) {
      logger.warn("".concat(name, " was loaded twice, this could have bad side-effects"));
    }
    _this.loaders[name] = registerCallback;
  };
  this.loadAddons = function(api) {
    Object.values(_this.loaders).forEach(function(value) {
      return value(api);
    });
  };
  this.promise = new Promise(function(res) {
    _this.resolve = function() {
      return res(_this.getChannel());
    };
  });
});
var KEY = "__STORYBOOK_ADDONS";
function getAddonsStore() {
  if (!import_global.default[KEY]) {
    import_global.default[KEY] = new AddonStore();
  }
  return import_global.default[KEY];
}
var addons = getAddonsStore();

// node_modules/@storybook/addons/dist/esm/make-decorator.js
init_define_import_meta_env();
init_es_function_name();
init_es_array_concat();
var makeDecorator = function makeDecorator2(_ref) {
  var name = _ref.name, parameterName = _ref.parameterName, wrapper = _ref.wrapper, _ref$skipIfNoParamete = _ref.skipIfNoParametersOrOptions, skipIfNoParametersOrOptions = _ref$skipIfNoParamete === void 0 ? false : _ref$skipIfNoParamete;
  var decorator = function decorator2(options) {
    return function(storyFn, context) {
      var parameters = context.parameters && context.parameters[parameterName];
      if (parameters && parameters.disable) {
        return storyFn(context);
      }
      if (skipIfNoParametersOrOptions && !options && !parameters) {
        return storyFn(context);
      }
      return wrapper(storyFn, context, {
        options,
        parameters
      });
    };
  };
  return function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof args[0] === "function") {
      return decorator().apply(void 0, args);
    }
    return function() {
      if (arguments.length > 1) {
        if (args.length > 1) {
          return decorator(args).apply(void 0, arguments);
        }
        return decorator.apply(void 0, args).apply(void 0, arguments);
      }
      throw new Error("Passing stories directly into ".concat(name, "() is not allowed,\n        instead use addDecorator(").concat(name, ") and pass options with the '").concat(parameterName, "' parameter"));
    };
  };
};

// node_modules/@storybook/addons/dist/esm/hooks.js
init_define_import_meta_env();
var import_es_array_iterator = __toESM(require_es_array_iterator());
init_es_object_to_string();
var import_es_string_iterator = __toESM(require_es_string_iterator());
init_es_weak_map();
init_web_dom_collections_iterator();
init_es_set();
init_web_dom_collections_for_each();
init_es_array_includes();
init_es_string_includes();
init_es_function_name();
init_es_array_map();
init_es_array_concat();
init_es_object_entries();
init_es_object_keys();
init_es_symbol();
init_es_symbol_description();
init_es_symbol_iterator();
init_es_array_from();
init_es_array_slice();
var import_es_regexp_exec = __toESM(require_es_regexp_exec());
var import_global2 = __toESM(require_window());

// node_modules/@storybook/core-events/dist/esm/index.js
init_define_import_meta_env();
var events;
(function(events2) {
  events2["CHANNEL_CREATED"] = "channelCreated";
  events2["CONFIG_ERROR"] = "configError";
  events2["STORY_INDEX_INVALIDATED"] = "storyIndexInvalidated";
  events2["STORY_SPECIFIED"] = "storySpecified";
  events2["SET_STORIES"] = "setStories";
  events2["SET_CURRENT_STORY"] = "setCurrentStory";
  events2["CURRENT_STORY_WAS_SET"] = "currentStoryWasSet";
  events2["FORCE_RE_RENDER"] = "forceReRender";
  events2["FORCE_REMOUNT"] = "forceRemount";
  events2["STORY_PREPARED"] = "storyPrepared";
  events2["STORY_CHANGED"] = "storyChanged";
  events2["STORY_UNCHANGED"] = "storyUnchanged";
  events2["STORY_RENDERED"] = "storyRendered";
  events2["STORY_MISSING"] = "storyMissing";
  events2["STORY_ERRORED"] = "storyErrored";
  events2["STORY_THREW_EXCEPTION"] = "storyThrewException";
  events2["STORY_RENDER_PHASE_CHANGED"] = "storyRenderPhaseChanged";
  events2["UPDATE_STORY_ARGS"] = "updateStoryArgs";
  events2["STORY_ARGS_UPDATED"] = "storyArgsUpdated";
  events2["RESET_STORY_ARGS"] = "resetStoryArgs";
  events2["SET_GLOBALS"] = "setGlobals";
  events2["UPDATE_GLOBALS"] = "updateGlobals";
  events2["GLOBALS_UPDATED"] = "globalsUpdated";
  events2["REGISTER_SUBSCRIPTION"] = "registerSubscription";
  events2["PREVIEW_KEYDOWN"] = "previewKeydown";
  events2["SELECT_STORY"] = "selectStory";
  events2["STORIES_COLLAPSE_ALL"] = "storiesCollapseAll";
  events2["STORIES_EXPAND_ALL"] = "storiesExpandAll";
  events2["DOCS_RENDERED"] = "docsRendered";
  events2["SHARED_STATE_CHANGED"] = "sharedStateChanged";
  events2["SHARED_STATE_SET"] = "sharedStateSet";
  events2["NAVIGATE_URL"] = "navigateUrl";
  events2["UPDATE_QUERY_PARAMS"] = "updateQueryParams";
})(events || (events = {}));
var esm_default3 = events;
var CHANNEL_CREATED = events.CHANNEL_CREATED;
var CONFIG_ERROR = events.CONFIG_ERROR;
var STORY_INDEX_INVALIDATED = events.STORY_INDEX_INVALIDATED;
var STORY_SPECIFIED = events.STORY_SPECIFIED;
var SET_STORIES = events.SET_STORIES;
var SET_CURRENT_STORY = events.SET_CURRENT_STORY;
var CURRENT_STORY_WAS_SET = events.CURRENT_STORY_WAS_SET;
var FORCE_RE_RENDER = events.FORCE_RE_RENDER;
var FORCE_REMOUNT = events.FORCE_REMOUNT;
var STORY_PREPARED = events.STORY_PREPARED;
var STORY_CHANGED = events.STORY_CHANGED;
var STORY_UNCHANGED = events.STORY_UNCHANGED;
var STORY_RENDERED = events.STORY_RENDERED;
var STORY_MISSING = events.STORY_MISSING;
var STORY_ERRORED = events.STORY_ERRORED;
var STORY_THREW_EXCEPTION = events.STORY_THREW_EXCEPTION;
var STORY_RENDER_PHASE_CHANGED = events.STORY_RENDER_PHASE_CHANGED;
var UPDATE_STORY_ARGS = events.UPDATE_STORY_ARGS;
var STORY_ARGS_UPDATED = events.STORY_ARGS_UPDATED;
var RESET_STORY_ARGS = events.RESET_STORY_ARGS;
var SET_GLOBALS = events.SET_GLOBALS;
var UPDATE_GLOBALS = events.UPDATE_GLOBALS;
var GLOBALS_UPDATED = events.GLOBALS_UPDATED;
var REGISTER_SUBSCRIPTION = events.REGISTER_SUBSCRIPTION;
var PREVIEW_KEYDOWN = events.PREVIEW_KEYDOWN;
var SELECT_STORY = events.SELECT_STORY;
var STORIES_COLLAPSE_ALL = events.STORIES_COLLAPSE_ALL;
var STORIES_EXPAND_ALL = events.STORIES_EXPAND_ALL;
var DOCS_RENDERED = events.DOCS_RENDERED;
var SHARED_STATE_CHANGED = events.SHARED_STATE_CHANGED;
var SHARED_STATE_SET = events.SHARED_STATE_SET;
var NAVIGATE_URL = events.NAVIGATE_URL;
var UPDATE_QUERY_PARAMS = events.UPDATE_QUERY_PARAMS;
var IGNORED_EXCEPTION = new Error("ignoredException");

// node_modules/@storybook/addons/dist/esm/hooks.js
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties3(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var globalWindow = import_global2.default.window;
var HooksContext = function() {
  function HooksContext2() {
    var _this = this;
    _classCallCheck3(this, HooksContext2);
    this.hookListsMap = void 0;
    this.mountedDecorators = void 0;
    this.prevMountedDecorators = void 0;
    this.currentHooks = void 0;
    this.nextHookIndex = void 0;
    this.currentPhase = void 0;
    this.currentEffects = void 0;
    this.prevEffects = void 0;
    this.currentDecoratorName = void 0;
    this.hasUpdates = void 0;
    this.currentContext = void 0;
    this.renderListener = function(storyId) {
      if (storyId !== _this.currentContext.id)
        return;
      _this.triggerEffects();
      _this.currentContext = null;
      _this.removeRenderListeners();
    };
    this.init();
  }
  _createClass3(HooksContext2, [{
    key: "init",
    value: function init() {
      this.hookListsMap = /* @__PURE__ */ new WeakMap();
      this.mountedDecorators = /* @__PURE__ */ new Set();
      this.prevMountedDecorators = this.mountedDecorators;
      this.currentHooks = [];
      this.nextHookIndex = 0;
      this.currentPhase = "NONE";
      this.currentEffects = [];
      this.prevEffects = [];
      this.currentDecoratorName = null;
      this.hasUpdates = false;
      this.currentContext = null;
    }
  }, {
    key: "clean",
    value: function clean() {
      this.prevEffects.forEach(function(effect) {
        if (effect.destroy) {
          effect.destroy();
        }
      });
      this.init();
      this.removeRenderListeners();
    }
  }, {
    key: "getNextHook",
    value: function getNextHook() {
      var hook = this.currentHooks[this.nextHookIndex];
      this.nextHookIndex += 1;
      return hook;
    }
  }, {
    key: "triggerEffects",
    value: function triggerEffects() {
      var _this2 = this;
      this.prevEffects.forEach(function(effect) {
        if (!_this2.currentEffects.includes(effect) && effect.destroy) {
          effect.destroy();
        }
      });
      this.currentEffects.forEach(function(effect) {
        if (!_this2.prevEffects.includes(effect)) {
          effect.destroy = effect.create();
        }
      });
      this.prevEffects = this.currentEffects;
      this.currentEffects = [];
    }
  }, {
    key: "addRenderListeners",
    value: function addRenderListeners() {
      this.removeRenderListeners();
      var channel = addons.getChannel();
      channel.on(STORY_RENDERED, this.renderListener);
    }
  }, {
    key: "removeRenderListeners",
    value: function removeRenderListeners() {
      var channel = addons.getChannel();
      channel.removeListener(STORY_RENDERED, this.renderListener);
    }
  }]);
  return HooksContext2;
}();
function hookify(fn) {
  return function() {
    var _ref = typeof (arguments.length <= 0 ? void 0 : arguments[0]) === "function" ? arguments.length <= 1 ? void 0 : arguments[1] : arguments.length <= 0 ? void 0 : arguments[0], hooks = _ref.hooks;
    var prevPhase = hooks.currentPhase;
    var prevHooks = hooks.currentHooks;
    var prevNextHookIndex = hooks.nextHookIndex;
    var prevDecoratorName = hooks.currentDecoratorName;
    hooks.currentDecoratorName = fn.name;
    if (hooks.prevMountedDecorators.has(fn)) {
      hooks.currentPhase = "UPDATE";
      hooks.currentHooks = hooks.hookListsMap.get(fn) || [];
    } else {
      hooks.currentPhase = "MOUNT";
      hooks.currentHooks = [];
      hooks.hookListsMap.set(fn, hooks.currentHooks);
      hooks.prevMountedDecorators.add(fn);
    }
    hooks.nextHookIndex = 0;
    var prevContext = globalWindow.STORYBOOK_HOOKS_CONTEXT;
    globalWindow.STORYBOOK_HOOKS_CONTEXT = hooks;
    var result = fn.apply(void 0, arguments);
    globalWindow.STORYBOOK_HOOKS_CONTEXT = prevContext;
    if (hooks.currentPhase === "UPDATE" && hooks.getNextHook() != null) {
      throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
    }
    hooks.currentPhase = prevPhase;
    hooks.currentHooks = prevHooks;
    hooks.nextHookIndex = prevNextHookIndex;
    hooks.currentDecoratorName = prevDecoratorName;
    return result;
  };
}
var numberOfRenders = 0;
var RENDER_LIMIT = 25;
var applyHooks = function applyHooks2(applyDecorators) {
  return function(storyFn, decorators) {
    var decorated = applyDecorators(hookify(storyFn), decorators.map(function(decorator) {
      return hookify(decorator);
    }));
    return function(context) {
      var _ref2 = context, hooks = _ref2.hooks;
      hooks.prevMountedDecorators = hooks.mountedDecorators;
      hooks.mountedDecorators = new Set([storyFn].concat(_toConsumableArray(decorators)));
      hooks.currentContext = context;
      hooks.hasUpdates = false;
      var result = decorated(context);
      numberOfRenders = 1;
      while (hooks.hasUpdates) {
        hooks.hasUpdates = false;
        hooks.currentEffects = [];
        result = decorated(context);
        numberOfRenders += 1;
        if (numberOfRenders > RENDER_LIMIT) {
          throw new Error("Too many re-renders. Storybook limits the number of renders to prevent an infinite loop.");
        }
      }
      hooks.addRenderListeners();
      return result;
    };
  };
};
var areDepsEqual = function areDepsEqual2(deps, nextDeps) {
  return deps.length === nextDeps.length && deps.every(function(dep, i) {
    return dep === nextDeps[i];
  });
};
var invalidHooksError = function invalidHooksError2() {
  return new Error("Storybook preview hooks can only be called inside decorators and story functions.");
};
function getHooksContextOrNull() {
  return globalWindow.STORYBOOK_HOOKS_CONTEXT || null;
}
function getHooksContextOrThrow() {
  var hooks = getHooksContextOrNull();
  if (hooks == null) {
    throw invalidHooksError();
  }
  return hooks;
}
function useHook(name, callback, deps) {
  var hooks = getHooksContextOrThrow();
  if (hooks.currentPhase === "MOUNT") {
    if (deps != null && !Array.isArray(deps)) {
      logger.warn("".concat(name, " received a final argument that is not an array (instead, received ").concat(deps, "). When specified, the final argument must be an array."));
    }
    var _hook = {
      name,
      deps
    };
    hooks.currentHooks.push(_hook);
    callback(_hook);
    return _hook;
  }
  if (hooks.currentPhase === "UPDATE") {
    var _hook2 = hooks.getNextHook();
    if (_hook2 == null) {
      throw new Error("Rendered more hooks than during the previous render.");
    }
    if (_hook2.name !== name) {
      logger.warn("Storybook has detected a change in the order of Hooks".concat(hooks.currentDecoratorName ? " called by ".concat(hooks.currentDecoratorName) : "", ". This will lead to bugs and errors if not fixed."));
    }
    if (deps != null && _hook2.deps == null) {
      logger.warn("".concat(name, " received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders."));
    }
    if (deps != null && _hook2.deps != null && deps.length !== _hook2.deps.length) {
      logger.warn("The final argument passed to ".concat(name, " changed size between renders. The order and size of this array must remain constant.\nPrevious: ").concat(_hook2.deps, "\nIncoming: ").concat(deps));
    }
    if (deps == null || _hook2.deps == null || !areDepsEqual(deps, _hook2.deps)) {
      callback(_hook2);
      _hook2.deps = deps;
    }
    return _hook2;
  }
  throw invalidHooksError();
}
function useMemoLike(name, nextCreate, deps) {
  var _useHook = useHook(name, function(hook) {
    hook.memoizedState = nextCreate();
  }, deps), memoizedState = _useHook.memoizedState;
  return memoizedState;
}
function useMemo(nextCreate, deps) {
  return useMemoLike("useMemo", nextCreate, deps);
}
function useCallback(callback, deps) {
  return useMemoLike("useCallback", function() {
    return callback;
  }, deps);
}
function useRefLike(name, initialValue) {
  return useMemoLike(name, function() {
    return {
      current: initialValue
    };
  }, []);
}
function useRef(initialValue) {
  return useRefLike("useRef", initialValue);
}
function triggerUpdate() {
  var hooks = getHooksContextOrNull();
  if (hooks != null && hooks.currentPhase !== "NONE") {
    hooks.hasUpdates = true;
  } else {
    try {
      addons.getChannel().emit(FORCE_RE_RENDER);
    } catch (e) {
      logger.warn("State updates of Storybook preview hooks work only in browser");
    }
  }
}
function useStateLike(name, initialState) {
  var stateRef = useRefLike(
    name,
    typeof initialState === "function" ? initialState() : initialState
  );
  var setState = function setState2(update) {
    stateRef.current = typeof update === "function" ? update(stateRef.current) : update;
    triggerUpdate();
  };
  return [stateRef.current, setState];
}
function useState(initialState) {
  return useStateLike("useState", initialState);
}
function useReducer(reducer, initialArg, init) {
  var initialState = init != null ? function() {
    return init(initialArg);
  } : initialArg;
  var _useStateLike = useStateLike("useReducer", initialState), _useStateLike2 = _slicedToArray(_useStateLike, 2), state = _useStateLike2[0], setState = _useStateLike2[1];
  var dispatch = function dispatch2(action) {
    return setState(function(prevState) {
      return reducer(prevState, action);
    });
  };
  return [state, dispatch];
}
function useEffect(create, deps) {
  var hooks = getHooksContextOrThrow();
  var effect = useMemoLike("useEffect", function() {
    return {
      create
    };
  }, deps);
  if (!hooks.currentEffects.includes(effect)) {
    hooks.currentEffects.push(effect);
  }
}
function useChannel(eventMap) {
  var deps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var channel = addons.getChannel();
  useEffect(function() {
    Object.entries(eventMap).forEach(function(_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2), type = _ref4[0], listener = _ref4[1];
      return channel.on(type, listener);
    });
    return function() {
      Object.entries(eventMap).forEach(function(_ref5) {
        var _ref6 = _slicedToArray(_ref5, 2), type = _ref6[0], listener = _ref6[1];
        return channel.removeListener(type, listener);
      });
    };
  }, [].concat(_toConsumableArray(Object.keys(eventMap)), _toConsumableArray(deps)));
  return useCallback(channel.emit.bind(channel), [channel]);
}
function useStoryContext() {
  var _getHooksContextOrThr = getHooksContextOrThrow(), currentContext = _getHooksContextOrThr.currentContext;
  if (currentContext == null) {
    throw invalidHooksError();
  }
  return currentContext;
}
function useParameter(parameterKey, defaultValue) {
  var _useStoryContext = useStoryContext(), parameters = _useStoryContext.parameters;
  if (parameterKey) {
    var _parameters$parameter;
    return (_parameters$parameter = parameters[parameterKey]) !== null && _parameters$parameter !== void 0 ? _parameters$parameter : defaultValue;
  }
  return void 0;
}
function useArgs() {
  var channel = addons.getChannel();
  var _useStoryContext2 = useStoryContext(), storyId = _useStoryContext2.id, args = _useStoryContext2.args;
  var updateArgs = useCallback(function(updatedArgs) {
    return channel.emit(UPDATE_STORY_ARGS, {
      storyId,
      updatedArgs
    });
  }, [channel, storyId]);
  var resetArgs = useCallback(function(argNames) {
    return channel.emit(RESET_STORY_ARGS, {
      storyId,
      argNames
    });
  }, [channel, storyId]);
  return [args, updateArgs, resetArgs];
}
function useGlobals() {
  var channel = addons.getChannel();
  var _useStoryContext3 = useStoryContext(), globals = _useStoryContext3.globals;
  var updateGlobals = useCallback(function(newGlobals) {
    return channel.emit(UPDATE_GLOBALS, {
      globals: newGlobals
    });
  }, [channel]);
  return [globals, updateGlobals];
}

// node_modules/@storybook/addons/dist/esm/public_api.js
init_define_import_meta_env();
var public_api_default = addons;

export {
  Channel,
  mockChannel,
  types,
  isSupportedType,
  AddonStore,
  addons,
  makeDecorator,
  esm_default3 as esm_default,
  NAVIGATE_URL,
  HooksContext,
  applyHooks,
  useMemo,
  useCallback,
  useRef,
  useState,
  useReducer,
  useEffect,
  useChannel,
  useStoryContext,
  useParameter,
  useArgs,
  useGlobals,
  public_api_default
};
//# sourceMappingURL=chunk-GDRHSWBZ.js.map

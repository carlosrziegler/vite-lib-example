import "core-js/modules/es.array.slice.js";
import "core-js/modules/es.object.freeze.js";

var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5;

import "regenerator-runtime/runtime.js";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

import "core-js/modules/es.object.to-string.js";
import "core-js/modules/es.promise.js";
import "core-js/modules/es.regexp.exec.js";
import "core-js/modules/es.array.iterator.js";
import "core-js/modules/es.string.iterator.js";
import "core-js/modules/web.dom-collections.iterator.js";
import "core-js/modules/es.array.map.js";
import "core-js/modules/es.array.filter.js";
import "core-js/modules/es.object.keys.js";
import "core-js/modules/es.symbol.js";
import "core-js/modules/es.symbol.description.js";
import "core-js/modules/es.array.concat.js";
import deprecate from 'util-deprecate';
import dedent from 'ts-dedent';
import global from 'global';
import { SynchronousPromise } from 'synchronous-promise';
import Events, { IGNORED_EXCEPTION } from '@storybook/core-events';
import { logger } from '@storybook/client-logger';
import { addons } from '@storybook/addons';
import { StoryStore } from '@storybook/store';
import { UrlStore } from './UrlStore';
import { WebView } from './WebView';
import { PREPARE_ABORTED, StoryRender } from './StoryRender';
import { DocsRender } from './DocsRender';
var globalWindow = global.window,
    fetch = global.fetch;

function focusInInput(event) {
  var target = event.target;
  return /input|textarea/i.test(target.tagName) || target.getAttribute('contenteditable') !== null;
}

var STORY_INDEX_PATH = './stories.json';
export var PreviewWeb = /*#__PURE__*/function () {
  function PreviewWeb() {
    var _global$FEATURES,
        _this = this;

    _classCallCheck(this, PreviewWeb);

    this.channel = void 0;
    this.serverChannel = void 0;
    this.urlStore = void 0;
    this.storyStore = void 0;
    this.view = void 0;
    this.getStoryIndex = void 0;
    this.importFn = void 0;
    this.renderToDOM = void 0;
    this.previewEntryError = void 0;
    this.currentSelection = void 0;
    this.currentRender = void 0;
    this.storyRenders = [];
    this.previousCleanup = void 0;
    this.channel = addons.getChannel();

    if ((_global$FEATURES = global.FEATURES) !== null && _global$FEATURES !== void 0 && _global$FEATURES.storyStoreV7 && addons.hasServerChannel()) {
      this.serverChannel = addons.getServerChannel();
    }

    this.view = new WebView();
    this.urlStore = new UrlStore();
    this.storyStore = new StoryStore(); // Add deprecated APIs for back-compat
    // @ts-ignore

    this.storyStore.getSelection = deprecate(function () {
      return _this.urlStore.selection;
    }, dedent(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n        `__STORYBOOK_STORY_STORE__.getSelection()` is deprecated and will be removed in 7.0.\n  \n        To get the current selection, use the `useStoryContext()` hook from `@storybook/addons`.\n      "], ["\n        \\`__STORYBOOK_STORY_STORE__.getSelection()\\` is deprecated and will be removed in 7.0.\n  \n        To get the current selection, use the \\`useStoryContext()\\` hook from \\`@storybook/addons\\`.\n      "]))));
  } // INITIALIZATION
  // NOTE: the reason that the preview and store's initialization code is written in a promise
  // style and not `async-await`, and the use of `SynchronousPromise`s is in order to allow
  // storyshots to immediately call `raw()` on the store without waiting for a later tick.
  // (Even simple things like `Promise.resolve()` and `await` involve the callback happening
  // in the next promise "tick").
  // See the comment in `storyshots-core/src/api/index.ts` for more detail.


  _createClass(PreviewWeb, [{
    key: "initialize",
    value: function initialize(_ref) {
      var _this2 = this;

      var getStoryIndex = _ref.getStoryIndex,
          importFn = _ref.importFn,
          getProjectAnnotations = _ref.getProjectAnnotations;
      // We save these two on initialization in case `getProjectAnnotations` errors,
      // in which case we may need them later when we recover.
      this.getStoryIndex = getStoryIndex;
      this.importFn = importFn;
      this.setupListeners();
      return this.getProjectAnnotationsOrRenderError(getProjectAnnotations).then(function (projectAnnotations) {
        return _this2.initializeWithProjectAnnotations(projectAnnotations);
      });
    }
  }, {
    key: "setupListeners",
    value: function setupListeners() {
      var _this$serverChannel;

      globalWindow.onkeydown = this.onKeydown.bind(this);
      (_this$serverChannel = this.serverChannel) === null || _this$serverChannel === void 0 ? void 0 : _this$serverChannel.on(Events.STORY_INDEX_INVALIDATED, this.onStoryIndexChanged.bind(this));
      this.channel.on(Events.SET_CURRENT_STORY, this.onSetCurrentStory.bind(this));
      this.channel.on(Events.UPDATE_QUERY_PARAMS, this.onUpdateQueryParams.bind(this));
      this.channel.on(Events.UPDATE_GLOBALS, this.onUpdateGlobals.bind(this));
      this.channel.on(Events.UPDATE_STORY_ARGS, this.onUpdateArgs.bind(this));
      this.channel.on(Events.RESET_STORY_ARGS, this.onResetArgs.bind(this));
      this.channel.on(Events.FORCE_RE_RENDER, this.onForceReRender.bind(this));
      this.channel.on(Events.FORCE_REMOUNT, this.onForceRemount.bind(this));
    }
  }, {
    key: "getProjectAnnotationsOrRenderError",
    value: function getProjectAnnotationsOrRenderError(getProjectAnnotations) {
      var _this3 = this;

      return SynchronousPromise.resolve().then(getProjectAnnotations).then(function (projectAnnotations) {
        _this3.renderToDOM = projectAnnotations.renderToDOM;

        if (!_this3.renderToDOM) {
          throw new Error(dedent(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n            Expected your framework's preset to export a `renderToDOM` field.\n\n            Perhaps it needs to be upgraded for Storybook 6.4?\n\n            More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field          \n          "], ["\n            Expected your framework's preset to export a \\`renderToDOM\\` field.\n\n            Perhaps it needs to be upgraded for Storybook 6.4?\n\n            More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field          \n          "]))));
        }

        return projectAnnotations;
      }).catch(function (err) {
        // This is an error extracting the projectAnnotations (i.e. evaluating the previewEntries) and
        // needs to be show to the user as a simple error
        _this3.renderPreviewEntryError('Error reading preview.js:', err);

        throw err;
      });
    } // If initialization gets as far as project annotations, this function runs.

  }, {
    key: "initializeWithProjectAnnotations",
    value: function initializeWithProjectAnnotations(projectAnnotations) {
      var _global$FEATURES2,
          _this4 = this;

      this.storyStore.setProjectAnnotations(projectAnnotations);
      this.setInitialGlobals();
      var storyIndexPromise;

      if ((_global$FEATURES2 = global.FEATURES) !== null && _global$FEATURES2 !== void 0 && _global$FEATURES2.storyStoreV7) {
        storyIndexPromise = this.getStoryIndexFromServer();
      } else {
        if (!this.getStoryIndex) {
          throw new Error('No `getStoryIndex` passed defined in v6 mode');
        }

        storyIndexPromise = SynchronousPromise.resolve().then(this.getStoryIndex);
      }

      return storyIndexPromise.then(function (storyIndex) {
        return _this4.initializeWithStoryIndex(storyIndex);
      }).catch(function (err) {
        _this4.renderPreviewEntryError('Error loading story index:', err);

        throw err;
      });
    }
  }, {
    key: "setInitialGlobals",
    value: function () {
      var _setInitialGlobals = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _ref2, globals;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _ref2 = this.urlStore.selectionSpecifier || {}, globals = _ref2.globals;

                if (globals) {
                  this.storyStore.globals.updateFromPersisted(globals);
                }

                this.emitGlobals();

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function setInitialGlobals() {
        return _setInitialGlobals.apply(this, arguments);
      }

      return setInitialGlobals;
    }()
  }, {
    key: "emitGlobals",
    value: function emitGlobals() {
      this.channel.emit(Events.SET_GLOBALS, {
        globals: this.storyStore.globals.get() || {},
        globalTypes: this.storyStore.projectAnnotations.globalTypes || {}
      });
    }
  }, {
    key: "getStoryIndexFromServer",
    value: function () {
      var _getStoryIndexFromServer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var result;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return fetch(STORY_INDEX_PATH);

              case 2:
                result = _context2.sent;

                if (!(result.status === 200)) {
                  _context2.next = 5;
                  break;
                }

                return _context2.abrupt("return", result.json());

              case 5:
                _context2.t0 = Error;
                _context2.next = 8;
                return result.text();

              case 8:
                _context2.t1 = _context2.sent;
                throw new _context2.t0(_context2.t1);

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function getStoryIndexFromServer() {
        return _getStoryIndexFromServer.apply(this, arguments);
      }

      return getStoryIndexFromServer;
    }() // If initialization gets as far as the story index, this function runs.

  }, {
    key: "initializeWithStoryIndex",
    value: function initializeWithStoryIndex(storyIndex) {
      var _global$FEATURES3,
          _this5 = this;

      return this.storyStore.initialize({
        storyIndex: storyIndex,
        importFn: this.importFn,
        cache: !((_global$FEATURES3 = global.FEATURES) !== null && _global$FEATURES3 !== void 0 && _global$FEATURES3.storyStoreV7)
      }).then(function () {
        var _global$FEATURES4;

        if (!((_global$FEATURES4 = global.FEATURES) !== null && _global$FEATURES4 !== void 0 && _global$FEATURES4.storyStoreV7)) {
          _this5.channel.emit(Events.SET_STORIES, _this5.storyStore.getSetStoriesPayload());
        }

        return _this5.selectSpecifiedStory();
      });
    } // Use the selection specifier to choose a story, then render it

  }, {
    key: "selectSpecifiedStory",
    value: function () {
      var _selectSpecifiedStory = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var _this$urlStore$select, storySpecifier, viewMode, args, storyId;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (this.urlStore.selectionSpecifier) {
                  _context3.next = 3;
                  break;
                }

                this.renderMissingStory();
                return _context3.abrupt("return");

              case 3:
                _this$urlStore$select = this.urlStore.selectionSpecifier, storySpecifier = _this$urlStore$select.storySpecifier, viewMode = _this$urlStore$select.viewMode, args = _this$urlStore$select.args;
                storyId = this.storyStore.storyIndex.storyIdFromSpecifier(storySpecifier);

                if (storyId) {
                  _context3.next = 8;
                  break;
                }

                if (storySpecifier === '*') {
                  this.renderStoryLoadingException(storySpecifier, new Error(dedent(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n            Couldn't find any stories in your Storybook.\n            - Please check your stories field of your main.js config.\n            - Also check the browser console and terminal for error messages.\n          "])))));
                } else {
                  this.renderStoryLoadingException(storySpecifier, new Error(dedent(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["\n            Couldn't find story matching '", "'.\n            - Are you sure a story with that id exists?\n            - Please check your stories field of your main.js config.\n            - Also check the browser console and terminal for error messages.\n          "])), storySpecifier)));
                }

                return _context3.abrupt("return");

              case 8:
                this.urlStore.setSelection({
                  storyId: storyId,
                  viewMode: viewMode
                });
                this.channel.emit(Events.STORY_SPECIFIED, this.urlStore.selection);
                this.channel.emit(Events.CURRENT_STORY_WAS_SET, this.urlStore.selection);
                _context3.next = 13;
                return this.renderSelection({
                  persistedArgs: args
                });

              case 13:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function selectSpecifiedStory() {
        return _selectSpecifiedStory.apply(this, arguments);
      }

      return selectSpecifiedStory;
    }() // EVENT HANDLERS
    // This happens when a config file gets reloaded

  }, {
    key: "onGetProjectAnnotationsChanged",
    value: function () {
      var _onGetProjectAnnotationsChanged = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(_ref3) {
        var getProjectAnnotations, projectAnnotations;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                getProjectAnnotations = _ref3.getProjectAnnotations;
                delete this.previewEntryError;
                _context4.next = 4;
                return this.getProjectAnnotationsOrRenderError(getProjectAnnotations);

              case 4:
                projectAnnotations = _context4.sent;

                if (this.storyStore.projectAnnotations) {
                  _context4.next = 9;
                  break;
                }

                _context4.next = 8;
                return this.initializeWithProjectAnnotations(projectAnnotations);

              case 8:
                return _context4.abrupt("return");

              case 9:
                _context4.next = 11;
                return this.storyStore.setProjectAnnotations(projectAnnotations);

              case 11:
                this.emitGlobals();
                this.renderSelection();

              case 13:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function onGetProjectAnnotationsChanged(_x) {
        return _onGetProjectAnnotationsChanged.apply(this, arguments);
      }

      return onGetProjectAnnotationsChanged;
    }()
  }, {
    key: "onStoryIndexChanged",
    value: function () {
      var _onStoryIndexChanged = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var storyIndex;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                delete this.previewEntryError;

                if (this.storyStore.projectAnnotations) {
                  _context5.next = 3;
                  break;
                }

                return _context5.abrupt("return");

              case 3:
                _context5.prev = 3;
                _context5.next = 6;
                return this.getStoryIndexFromServer();

              case 6:
                storyIndex = _context5.sent;

                if (this.storyStore.storyIndex) {
                  _context5.next = 10;
                  break;
                }

                _context5.next = 10;
                return this.initializeWithStoryIndex(storyIndex);

              case 10:
                _context5.next = 12;
                return this.onStoriesChanged({
                  storyIndex: storyIndex
                });

              case 12:
                _context5.next = 18;
                break;

              case 14:
                _context5.prev = 14;
                _context5.t0 = _context5["catch"](3);
                this.renderPreviewEntryError('Error loading story index:', _context5.t0);
                throw _context5.t0;

              case 18:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[3, 14]]);
      }));

      function onStoryIndexChanged() {
        return _onStoryIndexChanged.apply(this, arguments);
      }

      return onStoryIndexChanged;
    }() // This happens when a glob gets HMR-ed

  }, {
    key: "onStoriesChanged",
    value: function () {
      var _onStoriesChanged = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_ref4) {
        var _global$FEATURES5;

        var importFn, storyIndex;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                importFn = _ref4.importFn, storyIndex = _ref4.storyIndex;
                _context6.next = 3;
                return this.storyStore.onStoriesChanged({
                  importFn: importFn,
                  storyIndex: storyIndex
                });

              case 3:
                if ((_global$FEATURES5 = global.FEATURES) !== null && _global$FEATURES5 !== void 0 && _global$FEATURES5.storyStoreV7) {
                  _context6.next = 10;
                  break;
                }

                _context6.t0 = this.channel;
                _context6.t1 = Events.SET_STORIES;
                _context6.next = 8;
                return this.storyStore.getSetStoriesPayload();

              case 8:
                _context6.t2 = _context6.sent;

                _context6.t0.emit.call(_context6.t0, _context6.t1, _context6.t2);

              case 10:
                if (!this.urlStore.selection) {
                  _context6.next = 15;
                  break;
                }

                _context6.next = 13;
                return this.renderSelection();

              case 13:
                _context6.next = 17;
                break;

              case 15:
                _context6.next = 17;
                return this.selectSpecifiedStory();

              case 17:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function onStoriesChanged(_x2) {
        return _onStoriesChanged.apply(this, arguments);
      }

      return onStoriesChanged;
    }()
  }, {
    key: "onKeydown",
    value: function onKeydown(event) {
      var _this$currentRender;

      if (!((_this$currentRender = this.currentRender) !== null && _this$currentRender !== void 0 && _this$currentRender.disableKeyListeners) && !focusInInput(event)) {
        // We have to pick off the keys of the event that we need on the other side
        var altKey = event.altKey,
            ctrlKey = event.ctrlKey,
            metaKey = event.metaKey,
            shiftKey = event.shiftKey,
            key = event.key,
            code = event.code,
            keyCode = event.keyCode;
        this.channel.emit(Events.PREVIEW_KEYDOWN, {
          event: {
            altKey: altKey,
            ctrlKey: ctrlKey,
            metaKey: metaKey,
            shiftKey: shiftKey,
            key: key,
            code: code,
            keyCode: keyCode
          }
        });
      }
    }
  }, {
    key: "onSetCurrentStory",
    value: function onSetCurrentStory(selection) {
      this.urlStore.setSelection(selection);
      this.channel.emit(Events.CURRENT_STORY_WAS_SET, this.urlStore.selection);
      this.renderSelection();
    }
  }, {
    key: "onUpdateQueryParams",
    value: function onUpdateQueryParams(queryParams) {
      this.urlStore.setQueryParams(queryParams);
    }
  }, {
    key: "onUpdateGlobals",
    value: function () {
      var _onUpdateGlobals = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(_ref5) {
        var globals;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                globals = _ref5.globals;
                this.storyStore.globals.update(globals);
                _context7.next = 4;
                return Promise.all(this.storyRenders.map(function (r) {
                  return r.rerender();
                }));

              case 4:
                if (!(this.currentRender instanceof DocsRender)) {
                  _context7.next = 7;
                  break;
                }

                _context7.next = 7;
                return this.currentRender.rerender();

              case 7:
                this.channel.emit(Events.GLOBALS_UPDATED, {
                  globals: this.storyStore.globals.get(),
                  initialGlobals: this.storyStore.globals.initialGlobals
                });

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function onUpdateGlobals(_x3) {
        return _onUpdateGlobals.apply(this, arguments);
      }

      return onUpdateGlobals;
    }()
  }, {
    key: "onUpdateArgs",
    value: function () {
      var _onUpdateArgs = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(_ref6) {
        var storyId, updatedArgs;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                storyId = _ref6.storyId, updatedArgs = _ref6.updatedArgs;
                this.storyStore.args.update(storyId, updatedArgs);
                _context8.next = 4;
                return Promise.all(this.storyRenders.filter(function (r) {
                  return r.id === storyId;
                }).map(function (r) {
                  return r.rerender();
                }));

              case 4:
                if (!(this.currentRender instanceof DocsRender)) {
                  _context8.next = 7;
                  break;
                }

                _context8.next = 7;
                return this.currentRender.rerender();

              case 7:
                this.channel.emit(Events.STORY_ARGS_UPDATED, {
                  storyId: storyId,
                  args: this.storyStore.args.get(storyId)
                });

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function onUpdateArgs(_x4) {
        return _onUpdateArgs.apply(this, arguments);
      }

      return onUpdateArgs;
    }()
  }, {
    key: "onResetArgs",
    value: function () {
      var _onResetArgs = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(_ref7) {
        var _this$currentRender2;

        var storyId, argNames, _ref8, initialArgs, argNamesToReset, updatedArgs;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                storyId = _ref7.storyId, argNames = _ref7.argNames;

                if (!(storyId === ((_this$currentRender2 = this.currentRender) === null || _this$currentRender2 === void 0 ? void 0 : _this$currentRender2.id))) {
                  _context9.next = 5;
                  break;
                }

                _context9.t0 = this.currentRender.story;
                _context9.next = 8;
                break;

              case 5:
                _context9.next = 7;
                return this.storyStore.loadStory({
                  storyId: storyId
                });

              case 7:
                _context9.t0 = _context9.sent;

              case 8:
                _ref8 = _context9.t0;
                initialArgs = _ref8.initialArgs;
                argNamesToReset = argNames || Object.keys(this.storyStore.args.get(storyId));
                updatedArgs = argNamesToReset.reduce(function (acc, argName) {
                  acc[argName] = initialArgs[argName];
                  return acc;
                }, {});
                _context9.next = 14;
                return this.onUpdateArgs({
                  storyId: storyId,
                  updatedArgs: updatedArgs
                });

              case 14:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function onResetArgs(_x5) {
        return _onResetArgs.apply(this, arguments);
      }

      return onResetArgs;
    }() // ForceReRender does not include a story id, so we simply must
    // re-render all stories in case they are relevant

  }, {
    key: "onForceReRender",
    value: function () {
      var _onForceReRender = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return Promise.all(this.storyRenders.map(function (r) {
                  return r.rerender();
                }));

              case 2:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function onForceReRender() {
        return _onForceReRender.apply(this, arguments);
      }

      return onForceReRender;
    }()
  }, {
    key: "onForceRemount",
    value: function () {
      var _onForceRemount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(_ref9) {
        var storyId;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                storyId = _ref9.storyId;
                _context11.next = 3;
                return Promise.all(this.storyRenders.filter(function (r) {
                  return r.id === storyId;
                }).map(function (r) {
                  return r.remount();
                }));

              case 3:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function onForceRemount(_x6) {
        return _onForceRemount.apply(this, arguments);
      }

      return onForceRemount;
    }() // RENDERING
    // We can either have:
    // - a story selected in "story" viewMode,
    //     in which case we render it to the root element, OR
    // - a story selected in "docs" viewMode,
    //     in which case we render the docsPage for that story

  }, {
    key: "renderSelection",
    value: function () {
      var _renderSelection = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
        var _this$currentSelectio, _this$currentSelectio2, _lastRender, _global$FEATURES6;

        var _ref10,
            persistedArgs,
            selection,
            storyId,
            storyIdChanged,
            viewModeChanged,
            lastSelection,
            lastRender,
            storyRender,
            implementationChanged,
            _storyRender$context,
            parameters,
            initialArgs,
            argTypes,
            args,
            _args12 = arguments;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _ref10 = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : {}, persistedArgs = _ref10.persistedArgs;
                selection = this.urlStore.selection;

                if (selection) {
                  _context12.next = 4;
                  break;
                }

                throw new Error('Cannot render story as no selection was made');

              case 4:
                storyId = selection.storyId;
                storyIdChanged = ((_this$currentSelectio = this.currentSelection) === null || _this$currentSelectio === void 0 ? void 0 : _this$currentSelectio.storyId) !== storyId;
                viewModeChanged = ((_this$currentSelectio2 = this.currentSelection) === null || _this$currentSelectio2 === void 0 ? void 0 : _this$currentSelectio2.viewMode) !== selection.viewMode; // Show a spinner while we load the next story

                if (selection.viewMode === 'story') {
                  this.view.showPreparingStory();
                } else {
                  this.view.showPreparingDocs();
                }

                lastSelection = this.currentSelection;
                lastRender = this.currentRender; // If the last render is still preparing, let's drop it right now. Either
                //   (a) it is a different story, which means we would drop it later, OR
                //   (b) it is the *same* story, in which case we will resolve our own .prepare() at the
                //       same moment anyway, and we should just "take over" the rendering.
                // (We can't tell which it is yet, because it is possible that an HMR is going on and
                //  even though the storyId is the same, the story itself is not).

                if (!((_lastRender = lastRender) !== null && _lastRender !== void 0 && _lastRender.isPreparing())) {
                  _context12.next = 14;
                  break;
                }

                _context12.next = 13;
                return this.teardownRender(lastRender);

              case 13:
                lastRender = null;

              case 14:
                storyRender = new StoryRender(this.channel, this.storyStore, this.renderToDOM, this.mainStoryCallbacks(storyId), storyId, 'story'); // We need to store this right away, so if the story changes during
                // the async `.prepare()` below, we can (potentially) cancel it

                this.currentSelection = selection; // Note this may be replaced by a docsRender after preparing

                this.currentRender = storyRender;
                _context12.prev = 17;
                _context12.next = 20;
                return storyRender.prepare();

              case 20:
                _context12.next = 29;
                break;

              case 22:
                _context12.prev = 22;
                _context12.t0 = _context12["catch"](17);

                if (!(_context12.t0 !== PREPARE_ABORTED)) {
                  _context12.next = 28;
                  break;
                }

                _context12.next = 27;
                return this.teardownRender(lastRender);

              case 27:
                this.renderStoryLoadingException(storyId, _context12.t0);

              case 28:
                return _context12.abrupt("return");

              case 29:
                implementationChanged = !storyIdChanged && !storyRender.isEqual(lastRender);
                if (persistedArgs) this.storyStore.args.updateFromPersisted(storyRender.story, persistedArgs);
                _storyRender$context = storyRender.context(), parameters = _storyRender$context.parameters, initialArgs = _storyRender$context.initialArgs, argTypes = _storyRender$context.argTypes, args = _storyRender$context.args; // Don't re-render the story if nothing has changed to justify it

                if (!(lastRender && !storyIdChanged && !implementationChanged && !viewModeChanged)) {
                  _context12.next = 37;
                  break;
                }

                this.currentRender = lastRender;
                this.channel.emit(Events.STORY_UNCHANGED, storyId);
                this.view.showMain();
                return _context12.abrupt("return");

              case 37:
                _context12.next = 39;
                return this.teardownRender(lastRender, {
                  viewModeChanged: viewModeChanged
                });

              case 39:
                // If we are rendering something new (as opposed to re-rendering the same or first story), emit
                if (lastSelection && (storyIdChanged || viewModeChanged)) {
                  this.channel.emit(Events.STORY_CHANGED, storyId);
                }

                if ((_global$FEATURES6 = global.FEATURES) !== null && _global$FEATURES6 !== void 0 && _global$FEATURES6.storyStoreV7) {
                  this.channel.emit(Events.STORY_PREPARED, {
                    id: storyId,
                    parameters: parameters,
                    initialArgs: initialArgs,
                    argTypes: argTypes,
                    args: args
                  });
                } // For v6 mode / compatibility
                // If the implementation changed, or args were persisted, the args may have changed,
                // and the STORY_PREPARED event above may not be respected.


                if (implementationChanged || persistedArgs) {
                  this.channel.emit(Events.STORY_ARGS_UPDATED, {
                    storyId: storyId,
                    args: args
                  });
                }

                if (selection.viewMode === 'docs' || parameters.docsOnly) {
                  this.currentRender = storyRender.toDocsRender();
                  this.currentRender.renderToElement(this.view.prepareForDocs(), this.renderStoryToElement.bind(this));
                } else {
                  this.storyRenders.push(storyRender);
                  this.currentRender.renderToElement(this.view.prepareForStory(storyRender.story));
                }

              case 43:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this, [[17, 22]]);
      }));

      function renderSelection() {
        return _renderSelection.apply(this, arguments);
      }

      return renderSelection;
    }() // Used by docs' modernInlineRender to render a story to a given element
    // Note this short-circuits the `prepare()` phase of the StoryRender,
    // main to be consistent with the previous behaviour. In the future,
    // we will change it to go ahead and load the story, which will end up being
    // "instant", although async.

  }, {
    key: "renderStoryToElement",
    value: function renderStoryToElement(story, element) {
      var _this6 = this;

      var render = new StoryRender(this.channel, this.storyStore, this.renderToDOM, this.inlineStoryCallbacks(story.id), story.id, 'docs', story);
      render.renderToElement(element);
      this.storyRenders.push(render);
      return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return _this6.teardownRender(render);

              case 2:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13);
      }));
    }
  }, {
    key: "teardownRender",
    value: function () {
      var _teardownRender = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(render) {
        var _ref12,
            viewModeChanged,
            _args14 = arguments;

        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _ref12 = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : {}, viewModeChanged = _ref12.viewModeChanged;
                this.storyRenders = this.storyRenders.filter(function (r) {
                  return r !== render;
                });
                _context14.next = 4;
                return render === null || render === void 0 ? void 0 : render.teardown({
                  viewModeChanged: viewModeChanged
                });

              case 4:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function teardownRender(_x7) {
        return _teardownRender.apply(this, arguments);
      }

      return teardownRender;
    }() // API

  }, {
    key: "extract",
    value: function () {
      var _extract = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(options) {
        var _global$FEATURES7;

        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                if (!this.previewEntryError) {
                  _context15.next = 2;
                  break;
                }

                throw this.previewEntryError;

              case 2:
                if (this.storyStore.projectAnnotations) {
                  _context15.next = 4;
                  break;
                }

                throw new Error(dedent(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["Failed to initialize Storybook.\n      \n      Do you have an error in your `preview.js`? Check your Storybook's browser console for errors."], ["Failed to initialize Storybook.\n      \n      Do you have an error in your \\`preview.js\\`? Check your Storybook's browser console for errors."]))));

              case 4:
                if (!((_global$FEATURES7 = global.FEATURES) !== null && _global$FEATURES7 !== void 0 && _global$FEATURES7.storyStoreV7)) {
                  _context15.next = 7;
                  break;
                }

                _context15.next = 7;
                return this.storyStore.cacheAllCSFFiles();

              case 7:
                return _context15.abrupt("return", this.storyStore.extract(options));

              case 8:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function extract(_x8) {
        return _extract.apply(this, arguments);
      }

      return extract;
    }() // UTILITIES

  }, {
    key: "mainStoryCallbacks",
    value: function mainStoryCallbacks(storyId) {
      var _this7 = this;

      return {
        showMain: function showMain() {
          return _this7.view.showMain();
        },
        showError: function showError(err) {
          return _this7.renderError(storyId, err);
        },
        showException: function showException(err) {
          return _this7.renderException(storyId, err);
        }
      };
    }
  }, {
    key: "inlineStoryCallbacks",
    value: function inlineStoryCallbacks(storyId) {
      return {
        showMain: function showMain() {},
        showError: function showError(err) {
          return logger.error("Error rendering docs story (".concat(storyId, ")"), err);
        },
        showException: function showException(err) {
          return logger.error("Error rendering docs story (".concat(storyId, ")"), err);
        }
      };
    }
  }, {
    key: "renderPreviewEntryError",
    value: function renderPreviewEntryError(reason, err) {
      this.previewEntryError = err;
      logger.error(reason);
      logger.error(err);
      this.view.showErrorDisplay(err);
      this.channel.emit(Events.CONFIG_ERROR, err);
    }
  }, {
    key: "renderMissingStory",
    value: function renderMissingStory() {
      this.view.showNoPreview();
      this.channel.emit(Events.STORY_MISSING);
    }
  }, {
    key: "renderStoryLoadingException",
    value: function renderStoryLoadingException(storySpecifier, err) {
      logger.error("Unable to load story '".concat(storySpecifier, "':"));
      logger.error(err);
      this.view.showErrorDisplay(err);
      this.channel.emit(Events.STORY_MISSING, storySpecifier);
    } // renderException is used if we fail to render the story and it is uncaught by the app layer

  }, {
    key: "renderException",
    value: function renderException(storyId, err) {
      this.channel.emit(Events.STORY_THREW_EXCEPTION, err);
      this.channel.emit(Events.STORY_RENDER_PHASE_CHANGED, {
        newPhase: 'errored',
        storyId: storyId
      }); // Ignored exceptions exist for control flow purposes, and are typically handled elsewhere.

      if (err !== IGNORED_EXCEPTION) {
        this.view.showErrorDisplay(err);
        logger.error("Error rendering story '".concat(storyId, "':"));
        logger.error(err);
      }
    } // renderError is used by the various app layers to inform the user they have done something
    // wrong -- for instance returned the wrong thing from a story

  }, {
    key: "renderError",
    value: function renderError(storyId, _ref13) {
      var title = _ref13.title,
          description = _ref13.description;
      logger.error("Error rendering story ".concat(title, ": ").concat(description));
      this.channel.emit(Events.STORY_ERRORED, {
        title: title,
        description: description
      });
      this.channel.emit(Events.STORY_RENDER_PHASE_CHANGED, {
        newPhase: 'errored',
        storyId: storyId
      });
      this.view.showErrorDisplay({
        message: title,
        stack: description
      });
    }
  }]);

  return PreviewWeb;
}();
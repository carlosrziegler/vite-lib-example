import { AnyFramework, StoryId, ViewMode, StoryContextForLoaders } from '@storybook/csf';
import { Story, RenderContext, StoryStore } from '@storybook/store';
import { Channel } from '@storybook/addons';
import { DocsRender } from './DocsRender';
export declare type RenderPhase = 'preparing' | 'loading' | 'rendering' | 'playing' | 'played' | 'completed' | 'aborted' | 'errored';
export declare type RenderContextCallbacks<TFramework extends AnyFramework> = Pick<RenderContext<TFramework>, 'showMain' | 'showError' | 'showException'>;
export declare const PREPARE_ABORTED: Error;
export declare class StoryRender<CanvasElement extends HTMLElement | void, TFramework extends AnyFramework> {
    private channel;
    private store;
    private renderToScreen;
    private callbacks;
    id: StoryId;
    viewMode: ViewMode;
    story?: Story<TFramework>;
    phase?: RenderPhase;
    private abortController?;
    private canvasElement?;
    private notYetRendered;
    disableKeyListeners: boolean;
    constructor(channel: Channel, store: StoryStore<TFramework>, renderToScreen: (renderContext: RenderContext<TFramework>, canvasElement: CanvasElement) => void | Promise<void>, callbacks: RenderContextCallbacks<TFramework>, id: StoryId, viewMode: ViewMode, story?: Story<TFramework>);
    private runPhase;
    prepare(): Promise<void>;
    isEqual(other?: StoryRender<CanvasElement, TFramework> | DocsRender<TFramework>): boolean;
    isPreparing(): boolean;
    isPending(): boolean;
    toDocsRender(): DocsRender<TFramework>;
    context(): Pick<StoryContextForLoaders<TFramework, import("@storybook/csf").Args>, string | number>;
    renderToElement(canvasElement: CanvasElement): Promise<void>;
    render({ initial, forceRemount, }?: {
        initial?: boolean;
        forceRemount?: boolean;
    }): Promise<void>;
    rerender(): Promise<void>;
    remount(): Promise<void>;
    cancelRender(): void;
    teardown(options?: {}): Promise<void>;
}
